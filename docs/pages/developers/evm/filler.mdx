# Hyperbridge Intent Filler

The Hyperbridge Intent Filler is an automated system that monitors cross-chain orders and fills them profitably. It acts as a bridge between users who want to move assets across chains and the underlying Hyperbridge protocol, earning fees by providing liquidity and execution services.

## ⚠️ Important Disclaimer

**Polytope Labs does not take responsibility for users running the filler, whether they make any profit or lose money.** Running a filler involves financial risk including but not limited to:

- **Loss of capital** due to gas costs, failed transactions, or market movements
- **Technical risks** from bugs, network issues, or configuration errors
- **Competition risks** from other fillers or market conditions
- **Smart contract risks** from protocol upgrades or vulnerabilities

**Use at your own risk. Only invest what you can afford to lose. This software is provided "as is" without warranty.**

## What Does the Filler Do?

The filler operates as a **profit-seeking agent** that:

1. **Monitors** multiple blockchain networks for new cross-chain orders
2. **Evaluates** each order for profitability and feasibility
3. **Waits** for sufficient blockchain confirmations based on order value
4. **Executes** profitable orders by providing the requested tokens on the destination chain
5. **Earns fees** from the difference between order fees and execution costs

Think of it as an automated market maker for cross-chain transactions - users pay fees for convenience, and fillers earn those fees by taking on the execution risk and capital requirements.

## Quick Start

### Option 1: Using Docker (Recommended)

Docker Hub provides pre-built images that are ready to run:

```bash
# Pull the latest image
docker pull polytopelabs/hyperbridge-filler:latest

# Create your config file

# Run the filler
docker run -d \
  --name hyperbridge-filler \
  --restart unless-stopped \
  -v $(pwd)/config.toml:/app/config.toml:ro \
  polytopelabs/hyperbridge-filler:latest
```

### Option 2: Using NPM (For Custom Strategies)

Install from NPM if you want to add custom strategies or modify the code:

```bash
# Install globally
npm install -g @hyperbridge/filler

# Generate configuration template
filler init -o filler-config.toml

# Edit the config with your settings (see Configuration section below)

# Run the filler
filler run -c filler-config.toml
```

### Option 3: Library Usage

```typescript
import { IntentFiller, BasicFiller, ConfirmationPolicy } from "@hyperbridge/filler"
import { FillerConfigService } from "@hyperbridge/filler"

// Configure chains and strategies
const configService = new FillerConfigService(chainConfigs, config)
const strategies = [new BasicFiller("0x...", configService)]

const filler = new IntentFiller(chainConfigs, strategies, fillerConfig, configService)
filler.start()
```

## How It Works

### Architecture Overview

The filler consists of several key components working together:

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   EventMonitor  │    │  IntentFiller   │    │   Strategies    │
│                 │    │                 │    │                 │
│ • Watches chains│───▶│ • Manages queues│───▶│ • BasicFiller   │
│ • Detects orders│    │ • Coordinates   │    │ • StableSwap    │
│ • Emits events  │    │   execution     │    │ • Custom...     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Execution Flow                               │
│                                                                 │
│ 1. Monitor detects OrderPlaced event on source chain            │
│ 2. Wait for confirmations based on order value & chain policy   │
│ 3. Evaluate order with all strategies for profitability         │
│ 4. Execute most profitable strategy on destination chain        │
│ 5. Emit orderFilled event with transaction hash                 │
└─────────────────────────────────────────────────────────────────┘
```

### Step-by-Step Process

1. **Event Detection**: The `EventMonitor` watches all configured chains for `OrderPlaced` events from IntentGateway contracts, polling every 1 second.

2. **Confirmation Waiting**: Before processing, the filler waits for blockchain confirmations. Higher-value orders require more confirmations for security (see Confirmation Policy below).

3. **Strategy Evaluation**: Each configured strategy evaluates the order:

    - **Eligibility Check**: Can we fill this order? (token balances, deadlines, etc.)
    - **Profitability Calculation**: Will this order be profitable after all costs?

4. **Queue Management**: Orders are processed using two queue levels:

    - **Global Queue**: Handles initial analysis and strategy evaluation (configurable concurrency)
    - **Chain-Specific Queues**: Ensures only one transaction per chain at a time (prevents nonce conflicts)

5. **Order Execution**: The most profitable strategy executes the fill transaction and emits success/failure events.

## Filling Strategies

The filler supports multiple strategies for different use cases. Each strategy implements the same interface but uses different logic for evaluation and execution.

### BasicFiller - Direct Token Transfers

**Best for**: Simple cross-chain transfers where you already hold the required tokens. This strategy is the fastest and most efficient way to fill orders.

**How it works**:

- Validates that input/output tokens match (e.g., USDC → USDC)
- Checks you have sufficient token balances on the destination chain
- Calculates profitability: `order fees - (gas costs + protocol fees)`
- Executes direct token transfers without any swapping

**Pros**:

- Lower gas costs (no swapping)
- Faster execution
- More predictable costs
- Suitable for high-frequency filling

**Cons**:

- Requires pre-positioning assets on all chains
- Limited to exact token matches
- Cannot capture arbitrage opportunities

```typescript
const strategy = new BasicFiller("0x...", configService)
```

### StableSwapFiller - With DEX Integration ⚠️ EXPERIMENTAL

**⚠️ WARNING**: StableSwapFiller is currently **experimental** and **not recommended for production use**. Use at your own risk.

**Best for**: Advanced users experimenting with arbitrage opportunities (testnet only recommended).

**How it works**:

- Can swap tokens on destination chain to fulfill orders
- Supports Uniswap V2, V3, and V4 protocols
- Calculates complex profitability including swap costs
- Executes swaps + fills in optimized transactions

**Pros**:

- Can fill orders without exact token matches
- Captures arbitrage opportunities
- Requires less pre-positioned capital
- Higher profit potential

**Cons**:

- ⚠️ **Experimental**: May have bugs or unexpected behavior
- Higher gas costs (swapping + filling)
- More complex execution (higher failure risk)
- Slippage risk on swaps
- Requires DEX liquidity

```typescript
// WARNING: Only use on testnets for now
const strategy = new StableSwapFiller("0x...", configService)
```

### Strategy Selection

The filler evaluates all configured strategies for each order and automatically selects the most profitable one. You can run multiple strategies simultaneously:

```toml
# Recommended: Use only BasicFiller for production
[[strategies]]
type = "basic"
privateKey = "0x..."

# EXPERIMENTAL: Only use on testnets
# [[strategies]]
# type = "stable-swap"
# privateKey = "0x..."
```

## How Profitability Works

Understanding profitability is crucial for running a successful filler. The filler only executes orders that will be profitable after all costs.

### Revenue Sources

**Order Fees**: Users specify a fixed fee amount when creating orders. This is your primary revenue source.

```
Order Fee = Fixed amount specified by user (not percentage-based). These amounts are denoted in the fee token of the respective chain. The fee token is fixed by the protocol. For example, on Ethereum mainnet, the fee token is DAI.
Examples: $2.80 in DAI, $1.50 in USDC, $5.00 in USDT
```

**Important**: Order fees are **fixed amounts**, not percentages. A $1 order and a $1M order can have the same fee.

### Cost Components

The filler calculates several costs before executing an order:

#### 1. Fill Transaction Gas Costs

- Gas to execute `fillOrder()` on destination chain
- Token approvals (if needed)
- Estimated using current gas prices

#### 2. Protocol Fees

- Hyperbridge protocol fees for cross-chain messaging
- Calculated as: `per-byte fee × message size`

#### 3. Relayer Fees

- Additional 25 cents on top of execution fees
- Covers the cost of posting proof back to source chain

#### 4. Swap Costs (StableSwapFiller only)

- DEX swap fees (0.05% - 1% depending on pool)
- Slippage costs
- Additional gas for swap execution

### Profitability Calculation

```
Basic Filler Profit = Order Fees - (Fill Gas + Protocol Fees + Relayer Fees)

StableSwap Profit = Order Fees - (Fill Gas + Swap Gas + Protocol Fees + Relayer Fees + Swap Costs)
```

### Example Calculation

For a 1000 USDC cross-chain order with $2.8 fee:

```
Revenue:
- Order Fee: $2.8 in Fee Token (DAI/USDT/USDC)

Costs:
- Fill Gas: ~$0.10 (varies by chain)
- Protocol Fee: ~$0.95 (per byte fee * message size)
- Relayer Fee: $0.25 (fixed)
- Total Costs: ~$1.30

Profit: $2.80 - $1.30 = $1.50
```

### Risk Factors

- **Gas Price Volatility**: High gas prices can eliminate profits
- **Order Competition**: Other fillers might fill orders first
- **Token Price Movements**: Prices can change between evaluation and execution
- **Slippage**: DEX trades might get worse prices than expected

## Custom Strategy

You can implement custom strategies for specialized use cases:

```typescript
import { FillerStrategy, Order, ExecutionResult } from "@hyperbridge/filler"

class MyArbitrageStrategy implements FillerStrategy {
	name = "ArbitrageStrategy"

	async canFill(order: Order): Promise<boolean> {
		// Check if arbitrage opportunity exists
		const priceA = await this.getTokenPrice(order.inputs[0].token, order.sourceChain)
		const priceB = await this.getTokenPrice(order.outputs[0].token, order.destChain)
		return priceA < priceB * 0.95 // 5% arbitrage threshold
	}

	async calculateProfitability(order: Order): Promise<bigint> {
		// Calculate arbitrage profit + order fees - costs
		const arbitrageProfit = await this.calculateArbitrage(order)
		const orderFees = order.fees
		const costs = await this.estimateCosts(order)
		return arbitrageProfit + orderFees - costs
	}

	async executeOrder(order: Order): Promise<ExecutionResult> {
		// Execute complex arbitrage + fill strategy
		return await this.executeArbitrageAndFill(order)
	}
}
```

## Configuration

### Confirmation Policy - Security vs Speed

The confirmation policy is a **critical security feature** that determines how many blockchain confirmations to wait for before processing an order. This prevents attacks from blockchain reorganizations (reorgs) where transactions can be reversed.

#### How It Works

The filler uses a **sliding scale** based on order value:

- **Low-value orders**: Fewer confirmations (faster processing)
- **High-value orders**: More confirmations (higher security)

```
Confirmations = Linear interpolation between min/max based on order value
```

#### Configuration Format

```toml
[confirmationPolicies."1"]  # Ethereum mainnet
minAmount = "1000"      # 1000 USD
maxAmount = "10000"    # 10000 USD
minConfirmations = 12                  # 12 blocks for small orders (~3 minutes)
maxConfirmations = 30                  # 30 blocks for large orders (~7.5 minutes)

[confirmationPolicies."97"]  # BSC testnet
minAmount = "1000"      # 1000 USD
maxAmount = "10000"    # 10000 USD
minConfirmations = 1                   # 1 block for small orders (~3 seconds)
maxConfirmations = 5                   # 5 blocks for large orders (~15 seconds)
```

#### Example Calculation

For a 5000 USD order on Ethereum:

- Min: 1000 USD → 12 confirmations
- Max: 10000 USD → 30 confirmations
- Order: 5000 USD → 20 confirmations

#### Chain-Specific Recommendations (With Approx Block Time Values)

| Chain    | Block Time | Low-Value | High-Value | Reasoning                                   |
| -------- | ---------- | --------- | ---------- | ------------------------------------------- |
| Ethereum | ~12s       | 2 blocks  | 20 blocks   | Highest security, slower finality (~6 min) |
| Arbitrum | ~0.25s     | 20 blocks | 100 blocks | Optimistic rollup, 7-day challenge period  |
| Base     | ~2s        | 10 blocks | 50 blocks  | Optimistic rollup on Ethereum L2           |
| BSC      | ~1s        | 5 blocks  | 10 blocks  | Faster blocks, validator-based consensus    |

#### Security Trade-offs

**More Confirmations**:

- ✅ Higher security against reorgs
- ✅ Safer for high-value orders
- ❌ Slower order processing
- ❌ Risk of being outcompeted by faster fillers

**Fewer Confirmations**:

- ✅ Faster order processing
- ✅ Competitive advantage
- ❌ Higher reorg risk
- ❌ Potential loss on reversed transactions

#### Best Practices

1. **Match Network Security**: More confirmations on less secure networks
2. **Consider Competition**: Balance security with speed to stay competitive
3. **Monitor Reorgs**: Track historical reorg data for your chains
4. **Start Conservative**: Begin with higher confirmations, optimize over time

## Docker Usage

Docker provides the easiest way to run the filler in production with proper isolation and resource management.

### Quick Docker Setup

```bash
# 1. Clone the repository
git clone <hyperbridge-sdk-repo>
cd packages/filler

# 2. Create configuration file
cp filler-config-example.toml config.toml
# Edit config.toml with your settings

# 3. Build and run with our helper script
./scripts/docker.sh build
./scripts/docker.sh run
```

### Docker Commands

The `docker.sh` script provides convenient commands:

```bash
# Build the Docker image
./scripts/docker.sh build

# Run as a container (daemon mode)
./scripts/docker.sh run

# Use Docker Compose for advanced setups
./scripts/docker.sh up      # Start services
./scripts/docker.sh down    # Stop services
./scripts/docker.sh logs    # View logs

# Get help
./scripts/docker.sh help
```

### Manual Docker Commands

If you prefer manual control:

```bash
# Build image
docker build -t polytopelabs/hyperbridge-filler:latest -f scripts/Dockerfile .

# Run container
docker run -d \
  --name hyperbridge-filler \
  --restart unless-stopped \
  -v $(pwd)/config.toml:/app/packages/filler/config/config.toml:ro \
  -e NODE_ENV=production \
  --log-driver json-file \
  --log-opt max-size=10m \
  --log-opt max-file=3 \
  polytopelabs/hyperbridge-filler:latest

# View logs
docker logs -f hyperbridge-filler

# Stop container
docker stop hyperbridge-filler
```

### Docker Compose

For production deployments with monitoring and persistence:

```yaml
version: "3.8"

services:
    filler:
        image: polytopelabs/hyperbridge-filler:latest
        container_name: hyperbridge-filler
        restart: unless-stopped
        volumes:
            - ./config.toml:/app/packages/filler/config/config.toml:ro
            - filler-logs:/app/logs
        environment:
            - NODE_ENV=production
        healthcheck:
            test: ["CMD", "/app/healthcheck.sh"]
            interval: 30s
            timeout: 10s
            retries: 3
        logging:
            driver: "json-file"
            options:
                max-size: "10m"
                max-file: "3"

volumes:
    filler-logs:
```

### Production Considerations

#### Environment Variables

```bash
# Override config values with environment variables
PRIVATE_KEY=0x...                           # Your private key
MAX_CONCURRENT_ORDERS=5                     # Order processing concurrency
LOG_LEVEL=info                              # Logging verbosity
COINGECKO_API_KEY=your_coingecko_pro_key   # CoinGecko Pro API key (required)
```

### Filler Configuration

```toml
[filler]
privateKey = "0x..."                 # Your private key (use env var in production)
maxConcurrentOrders = 5              # Max orders processed simultaneously

[filler.pendingQueue]
maxRechecks = 10                     # Max times to recheck failed orders
recheckDelayMs = 30000               # Delay between rechecks (30 seconds)

[filler.coingecko]                   # REQUIRED: CoinGecko Pro API key
apiKey = "your_coingecko_pro_key"    # Pro plan needed for unlimited requests
```

## Complete Configuration Example

Here's a comprehensive configuration file for a multi-chain filler:

```toml
# Main filler configuration
[filler]
privateKey = "0x..."                    # Your private key (use env var in production)
maxConcurrentOrders = 5                 # Process up to 5 orders simultaneously

# Queue configuration for failed orders
[filler.pendingQueue]
maxRechecks = 10                        # Retry failed orders up to 10 times
recheckDelayMs = 30000                  # Wait 30 seconds between retries

# REQUIRED: CoinGecko API for price feeds (no rate limits)
[filler.coingecko]
apiKey = "your_coingecko_pro_api_key"   # Pro plan required for unlimited requests

# Strategy configurations
[[strategies]]
type = "basic"                          # Direct token transfers
privateKey = "0x..."                    # Can be same or different key

[[strategies]]
type = "stable-swap"                    # With DEX integration
privateKey = "0x..."                    # For arbitrage opportunities

# Chain configurations - PREMIUM RPCs REQUIRED
[[chains]]
chainId = 1                             # Ethereum Mainnet
rpcUrl = "https://eth-mainnet.g.alchemy.com/v2/YOUR_ALCHEMY_PRO_KEY"

[[chains]]
chainId = 42161                         # Arbitrum
rpcUrl = "https://arb-mainnet.g.alchemy.com/v2/YOUR_ALCHEMY_PRO_KEY"

[[chains]]
chainId = 8453                          # Base
rpcUrl = "https://base-mainnet.g.alchemy.com/v2/YOUR_ALCHEMY_PRO_KEY"

[[chains]]
chainId = 56                            # BSC
rpcUrl = "https://bsc-dataseed.binance.org/"

# Confirmation policies per chain
[confirmationPolicies."1"]              # Ethereum - slower but secure
minAmount = "1000"       # 1000 USD
maxAmount = "10000"     # 10000 USD
minConfirmations = 2                   # ~24 seconds
maxConfirmations = 20                   # ~240 seconds

[confirmationPolicies."42161"]          # Arbitrum - needs more confirmations
minAmount = "1000"       # 1000 USD
maxAmount = "10000"      # 10000 USD
minConfirmations = 20                   # ~5 seconds
maxConfirmations = 100                  # ~25 seconds

[confirmationPolicies."8453"]           # Base - optimistic rollup
minAmount = "1000"       # 1000 USD
maxAmount = "10000"      # 10000 USD
minConfirmations = 10                   # ~20 seconds
maxConfirmations = 50                   # ~100 seconds

[confirmationPolicies."56"]             # BSC - fast consensus
minAmount = "1000"       # 1000 USD
maxAmount = "10000"      # 10000 USD
minConfirmations = 5                    # ~5 seconds
maxConfirmations = 10                   # ~10 seconds
```

## Event Monitoring

The filler emits events you can listen to for monitoring and analytics:

```typescript
import { IntentFiller } from "@hyperbridge/filler"

const filler = new IntentFiller(chainConfigs, strategies, config, configService)

// New order detected
filler.monitor.on("newOrder", ({ order }) => {
	console.log(`📋 New Order: ${order.id}`)
	console.log(`   Route: ${order.sourceChain} → ${order.destChain}`)
	console.log(`   Value: ${order.inputs[0].amount} ${order.inputs[0].token}`)
	console.log(`   Fee: ${order.fees}`)
})

// Order successfully filled
filler.monitor.on("orderFilled", ({ orderId, hash }) => {
	console.log(`✅ Order Filled: ${orderId}`)
	console.log(`   Transaction: ${hash}`)
})

// Custom event handling for analytics
filler.monitor.on("newOrder", async ({ order }) => {
	// Send to analytics service
	await analytics.track("order_detected", {
		orderId: order.id,
		sourceChain: order.sourceChain,
		destChain: order.destChain,
		value: order.inputs[0].amount.toString(),
	})
})
```

## Requirements & Setup

### Prerequisites

1. **Private Key with Funds**:

    - ETH/native tokens for gas fees on all chains
    - Tokens you want to fill orders with (USDC, USDT, DAI, etc.)
    - Minimum recommended: $1000 equivalent per chain

2. **Premium RPC Endpoints** (Required):

    - **Premium RPC providers only** (Alchemy Pro, Infura Growth+, QuickNode Pro)
    - **Must support**: `eth_call` with state overrides, `debug_traceCall`, gas simulation
    - **Archive nodes required** for storage slot detection and gas estimation
    - **High rate limits** to handle frequent polling and simulation calls
    - **Low latency** for competitive order execution

3. **Infrastructure**:
    - Stable internet connection with low latency
    - Server/VPS with 1GB+ RAM
    - Monitoring and alerting setup

### Initial Setup Checklist

```bash
# 1. Install filler
npm install -g @hyperbridge/filler

# 2. Generate configuration
filler init -o config.toml

# 3. Edit configuration with your settings
# - Add your private key (use environment variable)
# - Configure RPC endpoints
# - Set confirmation policies
# - Choose strategies

# 4. Fund your wallet on all chains
# - Native tokens for gas
# - Stablecoins for filling orders

# 5. Test on testnets first
# - BSC Testnet (chainId: 97)
# - Gnosis Chiado (chainId: 10200)

# 6. Run the filler
filler run -c config.toml

# 7. Monitor logs and performance
tail -f filler.log
```

### Security Best Practices

⚠️ **Critical Security Notes**:

- **Never commit private keys** to version control
- **Use environment variables** for sensitive data
- **Start with small amounts** to test the system
- **Monitor for unusual activity** and failed transactions
- **Keep RPC endpoints secure** (use API keys, whitelist IPs)
- **Regular backups** of configuration and logs
- **Update regularly** for security patches

## Troubleshooting

### Common Issues and Solutions

#### 1. "No profitable strategy found for order"

**Symptoms**: Orders detected but never filled, logs show profitability calculations resulting in 0 or negative profit.

**Causes**:

- Gas prices too high relative to order fees
- Insufficient token balances
- Order fees too low
- Competition from other fillers

**Solutions**:

```bash
# Check your token balances
filler balance -c config.toml

# Monitor gas prices
echo "Check current gas prices on your chains"

# Adjust confirmation policy for faster execution
[confirmationPolicies."1"]
minConfirmations = 6  # Reduce from 12 for faster execution
maxConfirmations = 20 # Reduce from 30
```

#### 2. "Insufficient token balances for order"

**Symptoms**: Filler skips orders, logs show balance check failures.

**Solutions**:

```bash
# Check balances on all chains
# Ensure you have:
# - Native tokens for gas
# - Stablecoins for filling (USDC, USDT)
# - Sufficient amounts for largest expected orders

# Example minimum balances per chain:
# - Any preferrable amount to conver gas costs among multiple orders
# - 10,000 USDC
# - 10,000 USDT
```

#### 3. RPC Rate Limiting

**Symptoms**: Frequent timeouts, "429 Too Many Requests" errors.

**Solutions**:

```toml
# Use ONLY premium RPC providers with advanced features
[[chains]]
chainId = 1
rpcUrl = "https://eth-mainnet.g.alchemy.com/v2/YOUR_ALCHEMY_PRO_KEY"  # Alchemy Pro required
# OR
rpcUrl = "https://mainnet.infura.io/v3/YOUR_INFURA_GROWTH_KEY"         # Infura Growth+ required

# Reduce polling frequency if needed
# (This is internal, but consider fewer concurrent orders)
[filler]
maxConcurrentOrders = 3  # Reduce from 5
```

#### 4. Orders Filled by Competitors

**Symptoms**: Orders detected but filled by others before you can execute.

**Solutions**:

```toml
# Reduce confirmation requirements (higher risk)
[confirmationPolicies."1"]
minConfirmations = 3  # More aggressive
maxConfirmations = 12

# Increase gas prices for faster inclusion
# (This requires code modification or future feature)

# Focus on less competitive chains
# Remove highly competitive chains like Ethereum mainnet
# Focus on Layer 2s with less competition
```

### Performance Optimization

#### 1. RPC Optimization

- **Use only premium RPC providers** (Alchemy Pro, Infura Growth+, QuickNode Pro)
- **Ensure advanced features**: State overrides, debug traces, gas simulation
- Choose geographically close providers for lower latency
- Consider running your own archive nodes for critical chains

#### 2. Strategy Optimization

- Start with BasicFiller for simplicity
- Add StableSwapFiller after gaining experience
- Monitor which strategy is more profitable

#### 3. Capital Efficiency

- Monitor token utilization across chains
- Rebalance tokens based on order flow
- Consider automated rebalancing strategies

### Getting Help

If you encounter issues not covered here:

1. **Check Logs**: Enable debug logging and examine error messages
2. **Community**: Join the Hyperbridge Discord/Telegram
3. **GitHub Issues**: Report bugs with full error logs and configuration
4. **Documentation**: Check the latest docs for updates
